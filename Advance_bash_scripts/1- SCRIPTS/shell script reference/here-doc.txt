eg:1
========
count=0

ssh -t -t "$other_host" << ENDSSH
  if [[ "${count}" == "0" ]]; then
    output="string1"
  else
    output="string2"
  fi
  echo "\$output"
  exit
ENDSSH

We use \$output so that it is expanded on remote host not locally.


eg:2
=======
if you want to suppress a command (find) to not count as variable.. 

use..

ssh user@host << 'ENDSSH'
echo -e \$(find ${WEB_IMG_BACKUPDIR}/ -type f | wc -l) files in ${WEB_IMG_BACKUPDIR}
ENDSSH


if you want to just expand variable echo..

ssh user@host <<ENDSSH
echo -e "${NEWPASS}\n${NEWPASS}" | passwd ${tmp_array[4]
ENDSSH


ref: http://stackoverflow.com/questions/7114990/pseudo-terminal-will-not-be-allocated-because-stdin-is-not-a-terminal

Today I learned that commands can be piped into bash and sh, and probably other shells too. I'm not sure how portable that mechanism is, but it seems like it would be widely supported. Thus, it seems like the simplest solution is to just combine ssh shell invocation with heredocs:

ssh user@server /bin/bash <<'EOT'
echo "These commands will be run on: $( uname -a )"
echo "They are executed by: $( whoami )"
EOT

For a syntactically "correct" way of constructing bash strings without relying upon pipes, however, here's a suitable approach:

ssh user@server "$( cat <<'EOT'
echo "These commands will be run on: $( uname -a )"
echo "They are executed by: $( whoami )"
EOT
)"



Per zanco's answer, you're not providing a remote command to ssh, given how the shell parses the command line.

The solution above fixes this problem in the following manner:

    ssh user@server is parsed by bash, and is interpreted to be the ssh command, followed by an argument user@server to be passed to the ssh command

    " begins an interpolated string, which when completed, will comprise an argument to be passed to the ssh command, which in this case will be interpreted by ssh to be the remote command to execute as user@server

    $( begins a command to be executed, with the output being captured by the surrounding interpolated string

    cat is a command to output the contents of whatever file follows. The output of cat will be passed back into the capturing interpolated string

    << begins a bash heredoc

    'EOT' specifies that the name of the heredoc is EOT. The single quotes ' surrounding EOT specifies that the heredoc should be parsed as a nowdoc, which is a special form of heredoc in which the contents do not get interpolated by bash, but rather passed on in literal format

    Any content that is encountered between <<'EOT' and <newline>EOT<newline> will be appended to the nowdoc output

    EOT terminates the nowdoc, resulting in a nowdoc temporary file being created and passed back to the calling cat command. cat outputs the nowdoc and passes the output back to the capturing interpolated string

    ) concludes the command to be executed

    " concludes the capturing interpolated string. The contents of the interpolated string will be passed back to ssh as a single command line argument, which ssh will interpret as the remote command to execute as user@server

UPDATE: If you need to avoid using external tools like cat, and don't mind having two statements instead of one, use the read built-in with a here-doc to generate the SSH command:

IFS='' read -r -d '' SSH_COMMAND <<'EOT'
echo "These commands will be run on: $( uname -a )"
echo "They are executed by: $( whoami )"
EOT

ssh user@server "${SSH_COMMAND}"

